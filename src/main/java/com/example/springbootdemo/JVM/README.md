# JVM

## 1.引用-Reference

### 1.1 四种引用类型

 _Java4种引用的级别由高到低依次为：_
 
    Strong     Soft      Weak       PhantomReference
    强引用  >  软引用  >  弱引用  >  虚引用
     
![对比](https://images2015.cnblogs.com/blog/647994/201702/647994-20170215235519441-1287012986.png) 
- 强引用: 
```
Object o=new Object();   //  强引用
```
- - 强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它.
  - 当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。
  - 如果不使用时，要通过如下方式来弱化引用，如下： 
  `o = null // 帮助垃圾收集器回收此对象`
  - 显式地设置o为null，或超出对象的生命周期范围，则gc认为该对象不存在引用，这时就可以回收这个对象。具体什么时候收集这要取决于gc的算法。
- 软引用:    
``` java
String str=new String("abc");                                 // 强引用
SoftReference<String> softRef=new SoftReference<String>(str);     // 软引用
```
-  - 如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。
- 弱引用: 
``` java
String str=new String("abc");    
WeakReference<String> abcWeakRef = new WeakReference<String>(str);
str=null;
```

-  - 弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。 
- 虚引用:

- - 虚引用需要java.lang.ref.PhantomReference类来实现，虚引用顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会觉定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收，它不能单独使用也不能通过它访问对象，虚引用必须和引用队列（ReferenceQueue）联合使用。
    虚引用的主要作用是跟踪对象被垃圾回收的状态，仅仅是提供了一种确保对象被finalize以后，做某些事情的机制。PhantomRefernce的get方法总是返回null,因此无法访问对应的引用对象，其意义在于说明一个对象已经进入finalization阶段，可以被gc回收，用来实现比finalization机制更灵活的回收操作。换句话说，设置虚引用关联的唯一目的，就是在这个对象被收集器回收的时候收到一个系统通知或者后续添加进一步处理。Java技术允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作

### 1.2 引用队列
#### 1.2.1 引用队列:ReferenceQueue

_引用队列是为了配合SoftReference、WeakReference、PhantomReference使用，它们三个在GC回收之前会被放到引用队列里_
![结构](https://img-blog.csdnimg.cn/20200203151225114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM3MzEzNjU3,size_16,color_FFFFFF,t_70)

### 1.3 小结
**java提供了4种引用类型，在垃圾回收的时候，都有自己各自的特点。ReferenceQueue是用来配合引用工作的，没有ReferenceQueue一样可以运行。
  创建引用时候可以指定关联的队列，当GC释放对象内存的时候，会将引用加入到引用队列，如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象内存被回收之前采取必要行动这相当于是一种通知机制。
  当关联的引用队列中有数据的时候，意味着引用指向的堆内存中的对象被回收。通过这种方式，JVM允许我们在对象被销毁后，做一些我们自己想做的事情。**
### 1.4 finalize
#### 1.4.1 定义
**finalize()是Object中的方法，当垃圾回收器将要回收对象所占内存之前被调用，即当一个对象被虚拟机宣告死亡时会先调用它finalize()方法，让此对象处理它生前的最后事情（这个对象可以趁这个时机挣脱死亡的命运）。要明白这个问题，先看一下虚拟机是如何判断一个对象该死的**

#### 1.4.2 回收判定
"GC ROOTS"定义：GC管理的主要区域是Java堆，一般情况下只针对堆进行垃圾回收。方法区、栈和本地方法区不被GC所管理,因而选择这些区域内的对象作为GC roots,被GC roots引用的对象不被GC回收。

"GC ROOTS"也可以看做是引用链的最顶级。

Java采用可达性分析算法来判定一个对象是否死期已到。Java中以一系列"GC  Roots"对象作为起点，如果一个对象的引用链可以最终追溯到"GC  Roots"对象，那就天下太平。
否则如果只是A对象引用B,B对象又引用A,A,B引用链均为能达到"GC  Roots"的话，那它俩将会被虚拟机宣判符合死亡条件，具有被垃圾回收器回收的资格。

